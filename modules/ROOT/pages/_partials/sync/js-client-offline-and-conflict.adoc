= Offline support

SDK provides first class support for performing GraphQL operations while offline.
Queries and mutations are hold in queue that is being configured to hold requests when client goes offline.
When client goes offline for long periods of time clients will be able still negotiate local updates with the server state thanks to powerful conflict resolution strategies.

image::./images/datasync-features.png[]

Client offers comprehensive set of features to perform data operations when offline.
Thanks to offline mutation store users can stage their changes to be replicated back
to server when becoming online:

image::./images/datasync-going_offline.png[]

Please follow chapters bellow for more information.

== Querying local cache

By default client will save all performed query results in the cache.
Data will be available to be used when application goes offline.
Queries are cached out of the box based on the type and `id` field.
When performing mutations that affects some queries users can use `refetchQueries` or `update` methods:

----
    client.mutate<Task>({
      mutation: ADD_TASK, variables: item,
      optimisticResponse: createOptimisticResponse('createTask', 'Task', item),
      update: this.updateCacheOnAdd
    });
----

== Making modifications when offline

AeroGear Sync SDK provides queue that stores mutations performed when offline.
By default queue saves data in storage to be available after application restarts.
Queue will hold requests until application will come back online.

Developers can adjust how queue will process new mutations by supplying custom `NetworkStatus` implementation.

=== Online Only Queries

To ensure certain queries are not queued and are always delivered to the network layer, you must make use of Graphql directives.
To do so on your client, ensure the query has the annotation attached like so:

----
exampleQuery(...) @onlineOnly {
  ...
}
----

=== Squashing Mutations

Multiple changes performed on the same object ID and with the same mutation will automatically be joined by the AeroGear Sync SDK when your client is offline. This is beneficial as the client will not have to queue a large amount of mutations to replay once it returns online.

==== Global Squashing

This feature is on by default at a global level. To disable it on a global level simply do so in your config:

[source,javascript]
----
let config = {
...
  mergeOfflineMutations: false
...
}
----

==== Mutation Level Squashing

To disable this feature at a mutation level be sure to include the annotation on the mutation like so:

----
exampleMutation(...) @noSquash {
  ...
}
----

== Listening for Events

It is possible to provide `offlineQueueListener` in config to be notified about offline related events:

* `onOperationEnqueued` - Called when new operation is being added to offline queue
* `onOperationSuccess` - Called when back online and operation succeeds
* `onOperationFailure` - Called when back online and operation fails with GraphQL error
* `queueCleared` - Called when offline operation queue is cleared

== Conflicts

When obtaining copy of the server side data, client data can get out of the sync.
Edits that happened on the client data need to be replicated back to server.
When replicating local changes to server it may happen that local changes no longer reflect the server state.
This situations are often called "Data Conflicts" or "Data Collisions"

Voyager client offers way to detect and handle conflicts for any GraphQL type by supplying
`ConflictLink` implementation to client.
When collision is detected it can be handled on both server or client.

See Voyager Server documentation for information about writing conflicts for the server.

=== Working with pluggable conflict implementations

Plugable conflict resolution allows developers to define way to determine how conflicts are detected and handled.
Conflict resolution can be fully controlled by server side implementation.
If users chose to resolve conflicts in the client they need to configure their resolvers first return conflict back to client.
Client will resolve them automatically basing on current strategy and notify listeners if developer supplied any.

Conflict resolution will work out of the box with recommended defaults and do not require any specific handling on the client.

____
Advanced users may customize conflict implementation by supplying custom `conflictStateProvider` in config.
____

=== Default conflict implementation

By default plugable conflict resolution is configured to rely on `version` field on each
GraphQL type.
For example:

`
type User {
  id: ID!
  version: String!
  name: String!
}
`

Version field is going to be controlled on the server and will map last version
that was sent from server. All operations on version field happen automatically
however users need to make sure that version field is always being passed to server
for mutations that supports conflict resolution:

----
type Mutation {
  updateUser(id: ID!, version: String!): User
}
----

Alternatively developers can create input element that can be reused in every mutation
that supports conflict resolution

----
type Mutation {
  updateUser(user: UserInput): User
}
----

=== Conflict resolution strategies

Client can define custom resolution strategies.
You can provide custom conflict resolution strategies to the client in the config by using the provided `ConflictResolutionStrategy` type from the SDK. By default developers do not need to pass any strategy (`clientVersionWins` strategy is used).
Custom strategies can be used also to provide different resolution strategy for certain operations:

[source,javascript]
----
let updateUserConflictResolver = (serverData, clientData) => {
    delete clientData.socialKey
    return Object.assign(serverData, clientData);
};

let updateTaskConflictResolver = (serverData, clientData) => {
    ...
};
----

NOTE: Client strategies will work only when specific server side resolver explicitly states that conflicts should be fixed on the client. Client strategy will be ignored when conflict is resolved on the server.

To use strategy pass it as argument to conflictStrategy in your config object:

[source,javascript]
----
let config = {
...
  conflictStrategy: {"TaskUpdated": updateTaskConflictResolver, "UserUpdated": updateUserConflictResolver}
...
}
----

=== Listening to conflicts

Framework allows to receive information about the data conflict that occurred between client and server. Client will be notified for both server and client conflicts.

Developers can supply their own `conflictListener` implementation

[source,typescript]
----
class ConflictLogger implements ConflictListener {
    console.log(`data: ${JSON.stringify(resolvedData)}, server: ${JSON.stringify(server)} client: ${JSON.stringify(client)} `);
  }
}

let config = {
...
  conflictListener: new ConflictLogger()
...
}
----

