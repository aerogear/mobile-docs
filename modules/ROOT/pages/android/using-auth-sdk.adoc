= AeroGear Services Auth SDK

Mobile authentication SDK based on link:http://www.keycloak.org/[Keycloak] using link:http://openid.net/connect/[OpenID Connect].

Provides authentication features like access control and two factor authentication through Keycloak.

image::https://img.youtube.com/vi/MGecRG11k6E/0.jpg[title="Demo Video (https://www.youtube.com/watch?v=MGecRG11k6E)", link="https://www.youtube.com/watch?v=MGecRG11k6E",caption=""]

== Usage

To use the Auth SDK you'll first need to:

* Have a Keycloak instance. See <<Setting up Keycloak>>.
* Import the Core module.
* A configuration file added to the apps assets directory. See <<Configuration file>>
* Specify the schema of the redirect url for your Android project in `android.defaultConfig.manifestPlaceholders` of the apps `build.gradle` file.
It should match the schema specified in the `Valid Redirect URL` section for the client in Keycloak.
It is recommended to use the package name of the Android app as the schema of the redirect url to avoid conflicts.
See link:../../example/src/build.gradle[the example app build.gradle file].

=== Setting up Keycloak

==== Using OpenShift

* If you do not have mobile services enabled in your openshift cluster follow this link:https://github.com/aerogear/mobile-core/blob/master/docs/walkthroughs/local-setup.adoc[Local Setup] guide.
* Navigate to your Openshift cluster and in the Service Catalog search for the Keycloak service.
* Click on the Keycloak service and you will be prompted to fill in details about your app.  For now you can leave these as they are.  Navigate through the setup and click Create.
This will provision the Keycloak service in the project you specified and create a public Client to be used with an app along with a bearer-only client.
See link:http://www.keycloak.org/docs/latest/server_admin/index.html#oidc-clients[Keycloak OIDC client documentation].

After provisioning, the Keycloak service will be available at the exposed Route. You can view this route inside your project or use the below command to get the route:
----
oc get route keycloak --template "http://{{.spec.host}} "
----
The route should look like `https://keycloak-myproject.192.168.37.1.nip.io/auth/`. +

==== Standalone

To setup standalone Keycloak follow Keycloak's guide link:/https://github.com/keycloak/keycloak/blob/master/README.md[here].

=== Adding dependency

Add dependency to your application module
----
dependencies {
    implementation "org.aerogear:aerogear-auth:[version]"
}
----

=== Configuration file

A `mobile-services.json` file must exist in the apps assets directory. It should specify configuration
for Keycloak. This configuration can be generated by the link:https://github.com/aerogear/mobile-cli[AeroGear Mobile CLI].

For an example of Keycloak configuration see link:../../example/src/main/assets/mobile-services.json[example apps mobile-services.json].

The Auth SDK will use this configuration to communicate with Keycloak.

=== Initializing the SDK

`AuthService` can be retrieved using the `MobileCore#getInstance` method.

[source,java]
----
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
----

Any subsequent `getService` call will return the same instance of `AuthService`.

Before the `AuthService` can be used `AuthService#init` must be invoked once in an app.

[source,java]
----
// Specify redirect URI. It is recommended to use the package name of your app.
AuthServiceConfiguration authServiceConfig = new AuthServiceConfiguration
    .AuthConfigurationBuilder()
    .withRedirectUri("org.aerogear.mobile.example:/callback")
    .build();

// You only need to invoke this once every subsequent retrieval of the AuthService
// will retrieve the same instance.
authService.init(context, authServiceConfig);
----

==== Authentication Browser

The `AuthService` can also be configured to whitelist or blacklist browsers that should or shouldn't be used during authentication.  During authentication the `Auth SDK` redirects the user to an internet browser.  A Keycloak login web page is loaded in this internet browser to allow users to authenticate.
`Authentication Browser` is referring to that internet browser used during authentication.  The `Auth SDK` provides some <<Pre-defined Browsers>> that can be used to be whitelisted or blacklisted and there is also the option to use <<Custom Browsers>>.
The `Auth SDK` can be configured to to use specific browsers and versions, this is know as `whitelist`, or the `Auth SDK` can be configured to permit specific browsers and versions, this is known as `blacklist`.  Once one or more internet browsers have been configured they can be configured to be blacklisted or whitelisted using <<Browser Configuration>>.


===== Pre-defined Browsers

There are some pre-defined browsers that can be be customised to be used as standalone or custom tab browsers and can target a specific version or version range.
There are also default options available where no extra configuration is needed.

A pre-defined browser can be retrieved from `AuthBrowsers`:

[source, java]
----
// a default Google Chrome browser. No extra configuration is neccessary.
AuthBrowser chromeBrowser = AuthBrowsers.CHROME_DEFAULT;

// a customisable Samsung browser where the custom tab mode has been set to `false` i.e.
// it should be used as a standalone browser and the version should be at least 6.
AuthBrowser samsungBrowser = AuthBrowsers.samsung(false, AuthBrowserVersionRange.atMost("6"));
----

For the full list of predefined browsers available see link:https://github.com/aerogear/aerogear-android-sdk/blob/master/auth/src/main/java/org/aerogear/mobile/auth/configuration/AuthBrowsers.java[AuthBrowsers.java].

===== Custom Browsers

To use a custom browser an link:https://github.com/aerogear/aerogear-android-sdk/blob/master/auth/src/main/java/org/aerogear/mobile/auth/configuration/AuthBrowser.java[AuthBrowser] object can be created:

[source, java]
----
AuthBrowser customBrowser = new AuthBrowser("custom.package.name", signatureSet, true, AuthBrowserVersionRange.ANY);
----

==== Browser Configuration

Once a browser or browsers have been configured, `BrowserConfiguration` can be used to either blacklist or whitelist these browsers.

IMPORTANT: It's only possible to blacklist or whitelist a browser/browsers. It is not possible to both whitelist and blacklist a browser/browsers.  If both are invoked the most previous browser configuration built will be used.

[source, java]
----
// blacklist the default Mozilla Firefox browser i.e. any version of Mozilla firefox for use as a standalone browser will be permitted for authentication
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().blackList().browser(AuthBrowsers.FIREFOX_DEFAULT).build();

// whitelist a custom Google Chrome browser i.e. a Google Chrome browser for use as a standalone browser where the version range is between 45 and 55.
AuthBrowser customChrome = AuthBrowsers.chrome(false, AuthBrowserVersionRange.between("45", "55"));
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().whitelist().browser(customChrome).build();

// blacklist the two browsers
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().blacklist().browser(AuthBrowsers.FIREFOX_DEFAULT).browser(customChrome).build();

// add the two browsers to a Set and whitelist the set of browsers
AuthBrowser samsungCustomTab = AuthBrowsers.SAMSUNG_CUSTOM_TAB;
Set<Browser> browsers = new HashSet<>(Arrays.asList(samsungCustomTab, customChrome));
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().whiteList().browsers(browsers).build();
----

The `AuthService` can be configured to use the browser configuration once its been instantiated:

[source,java]
----
// auth service configuration
AuthServiceConfiguration authServiceConfig = new AuthServiceConfiguration
    .AuthConfigurationBuilder()
    .withRedirectUri("org.aerogear.mobile.example:/callback")
    .build();

// browser configuration
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder()
    .blackList()
    .browser(AuthBrowsers.CHROME_CUSTOM_TAB)
    .build();

authService.init(context, authServiceConfig, browserConfiguration);
----

==== Defining Custom Scopes
Optionally, scopes can be defined for the auth request using a space as the delimiter as per https://tools.ietf.org/html/rfc6749#section-3.3[RFC-6749].
By default, the `"openid"` scope is sent if no scopes are defined.
[source,java]
----
// default is 'openid' when not defined
.withScopes("openid offline_access")
----

If `AuthService#init` is not invoked then an `IllegalStateException` will be thrown when using the
service.

=== Retrieving the current user

To retrieve the current authenticated user the `AuthService#currentUser` method can be invoked. This will be `null` if there is
no user authenticated. So it can be used to check whether to start the authentication flow or not.

[source,java]
----
// authService already initialized.
UserPrincipal currentUser = authService.currentUser();

if (currentUser != null) {
    // User is authenticated, get the users username
    String userName = currentUser.getUsername();
    // Get the users first name
    String firstName = currentUser.getFirstName();
    // Get the users last name
    String lastName = currentUser.getLastName();
    // Get the users email address
    String userEmail = currentUser.getEmail();
    // Get the access token of the authenticated user
    String accessToken = currentUser.getAccessToken();
    // Get the identity token of the authenticated user
    String identityToken = currentUser.getIdentityToken();
    // Get the refresh token of the authenticated user
    String refreshToken = currentUser.getRefreshToken();
} else {
    // User is not authenticated, start authentication flow
}
----

==== Retrieving Custom User Attributes

A walkthrough has been provided in the link:./auth-user-attributes.adoc[Keycloak Custom User Attributes] document to show how you can allow custom user attributes in Keycloak to be available in the Identity token.

You can then retrieve the custom attributes from the current user.

[source,java]
----
boolean booleanAttribute = currentUser.getCustomBooleanAttribute("booleanAttribute");
int intAttribute = currentUser.getCustomIntegerAttribute("intAttribute");
long longAttribute = currentUser.getCustomLongAttribute("longAttribute");
String stringAttribute = currentUser.getCustomStringAttribute("stringAttribute");

----

=== Authenticating

To start the authentication invoke the `AuthService#login` method.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);

static int LOGIN_RESULT_CODE = 1;

// Build the options object and start the authentication flow. 
// Provide an activity to handle the auth response.
DefaultAuthenticateOptions options = 
    new DefaultAuthenticateOptions(myActivity, LOGIN_RESULT_CODE);

Callback authCallback = new Callback<UserPrincipal>() {
    @Override
    public void onSuccess(UserPrincipal principal) {
        // User authenticated in, continue on..
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during login.
    }
};

authService.login(options, authCallback);
----

Once the browser returns to the app the result can be handled. In the activity provided to the
`login` method override `onActivityResult`. This handler should always invoke
`AuthService#handleAuthResponse`, providing the `Intent`. This will exchange the temporary tokens
returned from `AuthService#login` for long-life tokens and will provide a `UserPrincipal` which can
be used to access a users details. If this is not invoked you will not have access to the
`UserPrincipal`.

More information about the user returned is available in link:../core/README.adoc[the auth module JavaDocs].

[source,java]
----
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == LOGIN_RESULT_CODE) {
        // The core will return the same instance of the auth service as before
        AuthService authService = mobileCore.getInstance(AuthService.class);
        authService.handleAuthResult(data);
    }
}
----

The callback provided in `AuthService#login` will be invoked.

=== Retrieving a users roles

Once a `UserPrincipal` has been retrieved the link:http://www.keycloak.org/docs/latest/server_admin/index.html#roles[roles] of the user can be listed and checked. This can
be used to perform client side access control, such as hiding UI components related to actions the
user doesn't have permissions to perform.

To list a users roles the `UserPrincipal#getRoles` method can be invoked.

Roles are divided into two types. Resource roles which belong to the client the user has
authenticated against, and Realm roles which belong to the realm the client is in.

To list a users realm roles  the `UserPrincipal#getRealmRoles` method can be invoked and 
to list a users resource roles the `UserPrincipal#getResourceRoles` can be invoked.

In order to check if a user has a specific role you can invoke the `UserPrincipal#hasResourceRole`
and `UserPrincipal#hasRealmRole` methods and provide the role name to check for.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

boolean hasAdminPermissions = currentUser.hasRealmRole("user_admin");
if (hasAdminPermissions) {
    // Show some component.
}

// Check if a user has a role from a specific resource named my_resource.
boolean isModerator = currentUser.hasResourceRole("my_resource", "user_moderator");
if (isModerator) {
    // Enable some button.
}
----

=== Logging out

To logout, invoke the `AuthService#logout` method. This accepts the `UserPrincipal` that was
provided by `AuthService#handleAuthResponse` and has a callback to determine if the logout to the Keycloak or OpenID Connect server was successful.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

authService.logout(currentUser, new Callback<UserPrincipal>() {
    @Override
    public void onSuccess() {
        // User Logged Out Successfully and Local Auth Tokens were Deleted
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during logout
    }
});
----

By default, the local tokens obtained during authentication are only deleted when the logout succeeded against the authentication server.
You can use the `AuthService#deleteTokens` function to delete the local authentication tokens as part of a failed logout, or for other use cases.

*Note:* To perform backchannel or federated logouts, you must enable the Backchannel Logout option for the federated identity provider. More information is available in the Keycloak documentation under  http://www.keycloak.org/docs/latest/server_admin/index.html#openid-connect-v1-0-identity-providers[OIDC Identity Providers].

=== Single Sign-on
A walkthrough on how to setup Single Sign-on across Android Applications can be seen under the link:./auth-single-sign-on.adoc[Single Sign-on Documentation].
