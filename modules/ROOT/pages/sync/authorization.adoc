include::{partialsdir}/attributes.adoc[]

:service-name: Data Sync

= Role Based Authorization in {sync-service}

== Prerequisites

* xref:./binding_to_keycloak.adoc[Binding {sync-service} to Keycloak].
* link:https://www.keycloak.org/docs/3.4/getting_started/index.html#creating-a-realm-and-user[Creating a Realm in Keycloak].
* link:https://www.keycloak.org/docs/3.4/authorization_services/index.html#_getting_started_hello_world_enabling_authz_services[Enabling Authorization Services in Keycloak].
* link:https://www.keycloak.org/docs/3.4/authorization_services/index.html#_policy_overview[Managing Policies in Keycloak]


Role based authorization can be applied to Queries, Mutations, Subscriptions and individual fields in a GraphQL schema, when {sync-service} is used with Keycloak. This means it is possible to restrict individual fields and/or operations defined in the GraphQL schema to users with specific roles.

Take a publishing platform as an example. Role Based Authorization could be used to ensure only users with the role `editor` can perform the `editPublication` mutation. 

== Using the `hasRole` Directive to Apply Role Based Authorization on a Schema

The following example demonstrates how the `hasRole` directive can be used to define role based authorization on various parts of a GraphQL schema. This example schema represents publishing application like a news or blog website.

----
type Post {
  id: ID!
  title: String!
  author: Author!
  content: String!
  createdAt: Int!
}

type Author {
  id: ID!
  name: String!
  posts: [Post]!
  address: String! @hasRole(role: "admin")
  age: Int! @hasRole(role: "admin")
}

type Query {
  allPosts:[Post]!
  getAuthor(id: ID!):Author!
}

type Mutation {
  editPost:[Post]! @hasRole(role: ["editor", "admin"])
  deletePost(id: ID!):[Post] @hasRole(role: "admin")
}
----

There are two types:

* `Post` - This might be an article or a blog post
* `Author` - This would represent the person that authored a Post

There are two Queries:

* `allPosts` - This might return a list of posts
* `getAuthor` - This would return details about an Author

There are two Mutations:

* `editPost` - This would edit an existing post
* `deletePost` - This would delete a post.

=== Role Based Authorization on Queries and Mutations

In the example schema, the `hasRole` directive has been applied to the `editPost` and `deletePost` mutations. The same could be done on Queries.

* Only users with the roles `editor` and/or `admin` are allowed to perform the `editPost` mutation.
* Only users with the role `admin` are allowed to perform the `deletePost` mutation.

This example shows how the `hasRole` directive can be used on various queries and mutations.

=== Role Based Authorization on Fields

In the example schema, the `Author` type has the fields `address` and `age` which both have `hasRole(role: "admin")` applied. 

This means that users without the role `admin` are not authorized to request these fields **in any query or mutation**.

For example, non admin users are allowed to run the `getAuthor` query, but they cannot request back the `address` or `age` fields.


